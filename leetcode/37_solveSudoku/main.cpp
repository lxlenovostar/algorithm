/*
编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
空白格用 '.' 表示。

答案被标成红色。

Note:

给定的数独序列只包含数字 1-9 和字符 '.' 。
你可以假设给定的数独只有唯一解。
给定数独永远是 9x9 形式的。
*/

#include <iostream>
#include <vector>
#include <set>

using namespace std;

class Solution {
public:
	vector<vector<char>> result;

	bool check_row(vector<vector<char>>& board, int i, char val) {

		for (int j = 0; j < 9; j++) {
			if (board[i][j] != '.' && board[i][j] == val) {
				return false;
			}

		} //for

		return true;

	}

	bool check_col(vector<vector<char>>& board, int j, char val) {

		for (int i = 0; i < 9; i++) {
			if (board[i][j] != '.' && board[i][j] == val) {
				return false;
			}

		} //for

		return true;
	}

	bool check_sub(vector<vector<char>>& board, int i, int j, char val) {
		int index_i = i/3*3;
		int index_j = j/3*3;
		
		int rowMax = index_i + 3;
		int colMax = index_j + 3;

		std::cout << "check_sub i: " << i << " j: " << j << " val: " << val << std::endl;

		for (int k = index_i; k < rowMax; k++) {
			for (int z = index_j; z < colMax; z++) {
				std::cout << "board i: "  << k << " j: " << z << " b: " << board[k][z] << std::endl;
				if (board[k][z] != '.' && board[k][z] == val) {
					return false;
				}
			}
		}
		
		return true;
	}

	bool helper(vector<vector<char>> board, int i, int j) {
		if (i >= 9) {
			result = board;
			std::cout << "what3" << std::endl;
			return true;
		} // if
		
		if (board[i][j] == '.') {
			std::cout << "what1" << std::endl;
			for (char val = '1' ; val <= '9'; val++)  {
				//check row 
				bool ret = check_row(board, i, val);
				if (ret == false)
					continue;

				//check col
				ret = check_col(board, j, val);
				if (ret == false)
					continue;
				
				//check sub 
				ret = check_sub(board, i, j, val);
				if (ret == false)
					continue;


				vector<vector<char>> new_board(board);
				new_board[i][j] = val;

				bool r = helper(new_board, i, j);
				if (r == true)
					return true;
			} //for
		
		} else {
			std::cout << "what2" << std::endl;

			if ((j+1) >= 9) 
				return helper(board, i+1, 0);
			else 
				return helper(board, i, j+1);
			
		} // if .

		return false;
	
	}

    void solveSudoku(vector<vector<char>>& board) {
		helper(board, 0, 0);
		board = result;
    }
};

int main() {
	/*
	[
		['5','3','1','2','7','6','4','9','8'],
		['6','2','3','1','9','5','8','4','7'],
		['1','9','8','3','4','7','5','6','2'],
		['8','1','2','7','6','4','9','5','3'],
		['4','7','9','8','5','3','6','2','1'],
		['7','4','5','9','2','8','3','1','6'],
		['9','6','7','5','3','1','2','8','4'],
		['2','8','6','4','1','9','7','3','5'],
		['3','5','4','6','8','2','1','7','9']
	]

	[
		['5','3','4','6','7','8','9','1','2'],
		['6','7','2','1','9','5','3','4','8'],
		['1','9','8','3','4','2','5','6','7'],
		['8','5','9','7','6','1','4','2','3'],
		['4','2','6','8','5','3','7','9','1'],
		['7','1','3','9','2','4','8','5','6'],
		['9','6','1','5','3','7','2','8','4'],
		['2','8','7','4','1','9','6','3','5'],
		['3','4','5','2','8','6','1','7','9']
	]
	*/

	/*
	[
		['1','3','9','7','4','8','6','5','2'],
		['7','4','2','5','9','6','1','3','8'],
		['5','2','6','1','3','9','7','8','4'],
		['3','5','7','6','8','1','2','4','9'],
		['8','6','4','3','1','2','5','9','7'],
		['6','9','8','4','2','7','3','1','5'],
		['9','7','5','8','6','3','4','2','1'],
		['2','1','3','9','5','4','8','7','6'],
		['4','8','1','2','7','5','9','6','3']
	]

	[
		['5','1','9','7','4','8','6','3','2'],
		['7','8','3','6','5','2','4','1','9'],
		['4','2','6','1','3','9','8','7','5'],
		['3','5','7','9','8','6','2','4','1'],
		['2','6','4','3','1','7','5','9','8'],
		['1','9','8','5','2','4','3','6','7'],
		['9','7','5','8','6','3','1','2','4'],
		['8','3','2','4','9','1','7','5','6'],
		['6','4','1','2','7','5','9','8','3']
	]
	*/

	vector<vector<char>> nums =	
    {	
		{'.','.','9','7','4','8','.','.','.'},
		{'7','.','.','.','.','.','.','.','.'},
		{'.','2','.','1','.','9','.','.','.'},
		{'.','.','7','.','.','.','2','4','.'},
		{'.','6','4','.','1','.','5','9','.'},
		{'.','9','8','.','.','.','3','.','.'},
		{'.','.','.','8','.','3','.','2','.'},
		{'.','.','.','.','.','.','.','.','6'},
		{'.','.','.','2','7','5','9','.','.'}
	};	
	
	/*
	vector<vector<char>> nums =	
	{
		{'5','3','.','.','7','.','.','.','.'},
		{'6','.','.','1','9','5','.','.','.'},
		{'.','9','8','.','.','.','.','6','.'},
		{'8','.','.','.','6','.','.','.','3'},
		{'4','.','.','8','.','3','.','.','1'},
		{'7','.','.','.','2','.','.','.','6'},
		{'.','6','.','.','.','.','2','8','.'},
		{'.','.','.','4','1','9','.','.','5'},
		{'.','.','.','.','8','.','.','7','9'}
	};
	*/


	Solution *obj = new Solution();
	obj->solveSudoku(nums);

	for (size_t i = 0; i < nums.size(); i++) {
		for (size_t j = 0; j < nums[i].size(); j++) {
			std::cout << nums[i][j] << ',';
		}
		std::cout << std::endl;
	}

	return 0;
}
